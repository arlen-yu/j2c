var
  emptyArray = [],
  emptyObject = {},
  emptyString = '',
  type = emptyObject.toString,
  ARRAY =  type.call(emptyArray),
  OBJECT = type.call(emptyObject),
  STRING = type.call(emptyString),
  FUNCTION = type.call(type),
  own =  emptyObject.hasOwnProperty

/*/-inline-/*/
// function cartesian(a, b, res, i, j) {
//   res = [];
//   for (j in b) if (own.call(b, j))
//     for (i in a) if (own.call(a, i))
//       res.push(a[i] + b[j]);
//   return res;
// }
/*/-inline-/*/

/* /-statements-/*/
function cartesian(a,b, selectorP, res, i, j) {
  res = []
  for (j in b) if(own.call(b, j))
    for (i in a) if(own.call(a, i))
      res.push(concat(a[i], b[j], selectorP))
  return res
}

function concat(a, b, selectorP) {
  // `b.replace(/&/g, a)` is never falsy, since the
  // 'a' of cartesian can't be the empty string
  // in selector mode.
  return selectorP && (
    /^[-\w$]+$/.test(b) && ':-error-bad-sub-selector-' + b ||
    /&/.test(b) && /* never falsy */ b.replace(/&/g, a)
  ) || a + b
}

// "Tokenizes" the selectors into parts relevant for the next function.
// Strings and comments are matched, but ignored afterwards.
// This is not a full tokenizers. It only recognizes comas, parentheses,
// strings and comments.
// regexp generated by scripts/regexps.js then trimmed by hand
var selectorTokenizer =  /[(),]|"(?:\\.|[^"\n])*"|'(?:\\.|[^'\n])*'|\/\*[\s\S]*?\*\//g

/**
 * This will split a coma-separated selector list into individual selectors,
 * ignoring comas in strings, comments and in :pseudo-selectors(parameter, lists).
 * @param {string} selector
 * @return {string[]}
 */

function splitSelector(selector) {
  var indices = [], res = [], inParen = 0, match, i
  /*eslint-disable no-cond-assign*/
  while(match = selectorTokenizer.exec(selector)) {
  /*eslint-enable no-cond-assign*/
    switch(match[0]){
    case '(': inParen++; break
    case ')': inParen--; break
    case ',': if (inParen) break; indices.push(match.index)
    }
  }
  for (i = indices.length; i--;){
    res.unshift(selector.slice(indices[i] + 1))
    selector = selector.slice(0, indices[i])
  }
  res.unshift(selector)
  return res
}
/* /-statements-/*/
function flatIter (f) {
  return function iter(arg) {
    if (type.call(arg) === ARRAY) for (var i= 0 ; i < arg.length; i ++) iter(arg[i])
    else f(arg)
  }
}

export {
  ARRAY, FUNCTION, OBJECT, STRING,
  cartesian, concat,
  emptyArray, emptyObject,
  flatIter, own,
  splitSelector, type
}