import {flatIter} from './helpers'
import {rules} from './rules'
import {declarations} from './declarations'

/**
 * Handles a single at-rules
 *
 * @param {object} state - holds the localizer- and walker-related methods
 *                         and state
 * @param {object} emit - the contextual emitters to the final buffer
 * @param {array} k - The parsed at-rule, including the parameters,
 *                    if takes both parameters and a block.
 *                    k == [match, fullAtRule, atRuleType, params?]
 *                    So in `@-webkit-keyframes foo`, we have
 *                     - match = "@-webkit-keyframes foo"
 *                     - fullAtRule = "@-webkit-keyframes"
 *                     - atRuleType = "keyframes"
 *                     - params = "foo"
 * @param {string|string[]|object|object[]} v - Either parameters for
 *                                              block-less rules or
 *                                              their block
 *                                              for the others.
 * @param {string} prefix - the current selector or the selector prefix
 *                          in case of nested rules
 * @param {boolean} local - are we in @local or in @global scope?
 * @param {string} nestingDepth - are we nested in an at-rule or a selector?
 */


export function modulesAtRules(next) {
  return function (state, emit, k, v, prefix, local, nestingDepth) {
    if (!k[3] && k[2] === 'global') {

      rules(state, emit, prefix, v, 0, nestingDepth)


    } else if (!k[3] && k[2] === 'local') {

      rules(state, emit, prefix, v, 1, nestingDepth)


    } else if (k[3] && k[2] === 'adopt') {

      if (!local || nestingDepth) return emit.err('@adopt global or nested: ' + k[0])

      if (!/^\.?[_A-Za-z][-\w]*$/.test(k[3])) return emit.err('bad adopter ' + JSON.stringify(k[3]) + ' in ' + k[0])

      var classes = []
      flatIter(function(adoptee, asString) {

        if(adoptee == null || !/^\.?[_A-Za-z][-\w]*(?:\s+\.?[_A-Za-z][-\w]*)*$/.test(asString = adoptee + '')) emit.err('bad adoptee '+ JSON.stringify(adoptee) + ' in ' + k[0])

        else classes.push(asString.replace(/\./g, ''))

      })(v)

      // we may end up with duplicate classes but AFAIK it has no consequences on specificity.
      if (classes.length) {
        state.localize(k[3] = k[3].replace(/\./g, ''))
        state.names[k[3]] += (' ' + classes.join(' '))
      }

    } else {
      if (local && k[3] && k[2] === 'keyframes') {

        k[3] = k[3].replace(
          // generated by script/regexps.js
          /(var\([^)]+\))|:?global\(\s*([_A-Za-z][-\w]*)\s*\)|()(-?[_A-Za-z][-\w]*)/,
          state.localizeReplacer
        )

      }
      next(state, emit, k, v, prefix, local, nestingDepth)
    }
  }
}
export function standardAtRules(next) {
  return function(state, emit, k, v, prefix, local, nestingDepth) {
    if (!k[3] && (k[2] === 'namespace' || k[2] === 'import' || k[2] === 'charset')) {
      flatIter(function(v) {

        emit.atrule(k[1], k[2], v)

      })(v)


    } else if (k[2] === 'font-face' || k[2] === 'page' || k[2] === 'viewport') {
      flatIter(function(v) {

        emit.atrule(k[1], k[2], k[3], 'decl')

        declarations(state, emit, '', v, local)

        emit._atrule()

      })(v)

    } else if (k[3] && (k[2] === 'keyframes' || k[2] === 'media' || k[2] === 'supports')) {

      emit.atrule(k[1], k[2], k[3], 'rule')

      rules(
        state, emit,
        'keyframes' == k[2] ? '' : prefix,
        v, local, nestingDepth + 1
      )

      emit._atrule()

    } else {

      next(state, emit, k, v, prefix, local, nestingDepth)

    }
  }
}

export function unsupportedAtRule(state, emit, k){
  emit.err('Unsupported at-rule: ' + k[0])
}
