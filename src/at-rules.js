import {type, ARRAY, splitSelector} from './helpers'
import {sheet} from './sheet'
import {declarations} from './declarations'

/**
 * Hanldes at-rules
 *
 * @param {string} k - The at-rule name, and, if takes both parameters and a
 *                     block, the parameters.
 * @param {string[]} buf - the buffer in which the final style sheet is built
 * @param {string[]} v - Either parameters for block-less rules or their block
 *                       for the others.
 * @param {string} prefix - the current selector or a prefix in case of nested rules
 * @param {string} composes - the potential target of a @composes rule, if any
 * @param {boolean} local - are we in @local or in @global scope?
 * @param {object} state - helper functions to populate or create the @local namespace
 *                      and to @extend classes
 * @param {function} state.e - @extend helper
 * @param {function} state.l - @local helper
 */

export function at(k, v, buf, prefix, composes, local, state){
  var i, kk, params
  if (/^@global$/.test(k)) {
    sheet(v, buf, prefix, 1, 0, state)

  } else if (/^@local$/.test(k)) {
    sheet(v, buf, prefix, 1, 1, state)

  } else if (/^@composes$/.test(k)) {
    if (!local) {
      buf.a('@-error-at-composes-in-at-global', '', '', ';\n')
      return
    }
    if (!composes) {
      buf.a('@-error-at-composes-no-nesting', '', '', ';\n')
      return
    }
    composes = splitSelector(composes)
    for(i = 0; i < composes.length; i++) {
      k = /^\s*\.(\w+)\s*$/.exec(composes[i])
      if (k == null) {
        // the last class is a :global(.one)
        buf.a('@-error-at-composes-bad-target', ' ', JSON.stringify(composes[i]), ';\n')
        continue
      }
      state.c(
        type.call(v) == ARRAY ? v.map(function (parent) {
          return parent.replace(/()(?::?global\(\s*\.?([-\w]+)\s*\)|()\.([-\w]+))/, state.l)
        }).join(' ') : v.replace(/()(?::?global\(\s*\.?([-\w]+)\s*\)|()\.([-\w]+))/, state.l),
        k[1]
      )
    }
  } else if (/^@(?:-[\w]+-)?(?:namespace|import|charset)$/.test(k)) {
    if(type.call(v) == ARRAY){
      for (kk = 0; kk < v.length; kk++) {
        buf.a(k, ' ', v[kk], ';\n')
      }
    } else {
      buf.a(k, ' ', v, ';\n')
    }
  } else if (/^@(?:-[\w]+-)?keyframes /.test(k)) {
    k = local ? k.replace(
      // generated by script/regexps.js
      /( )(?::?global\(\s*([-\w]+)\s*\)|()([-\w]+))/,
      state.l
    ) : k
    params = k.slice(k.indexOf(' ')+1)
    k = k.slice(0, k.indexOf(' '))

    buf.a(k, ' ', params, ' {\n')
    sheet(v, buf, '', 1, local, state)
    buf.c('}\n')

  } else if (/^@(?:-[\w]+-)?(?:font-face$|viewport$|page\b\s*(.+))/.test(k)) {
    params = k.match(/^@(?:-[\w]+-)?(?:font-face$|viewport$|page\b\s*(.+))/)[1] || ''
    k = k.match(/^@(?:-[\w]+-)?(?:font-face$|viewport$|page)/)[0]
    if (type.call(v) === ARRAY) {
      for (kk = 0; kk < v.length; kk++) {
        buf.a(k, params && ' ', params, ' {\n')
        declarations(v[kk], buf, '', local, state)
        buf.c('}\n')
      }
    } else {
      buf.a(k, params && ' ', params, ' {\n')
      declarations(v, buf, '', local, state)
      buf.c('}\n')
    }

  } else if (/^@(?:-[\w]+-)?(?:media|supports|document)\b\s*(.+)/.test(k)) {
    params = k.match(/^@(?:-[\w]+-)?(?:media|supports|document)\b\s*(.+)/)[1]
    k = k.match(/^@(?:-[\w]+-)?(?:media|supports|document)/)[0]
    buf.a(k, ' ', params, ' {\n')
    sheet(v, buf, prefix, 1, local, state)
    buf.c('}\n')

  } else {
    buf.a('@-error-unsupported-at-rule ', JSON.stringify(k), ';\n')
  }
}
