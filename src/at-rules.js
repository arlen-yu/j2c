import {flatIter, randIdentifier} from './helpers'
import {rules} from './rules'
import {declarations} from './declarations'

/**
 * Handle at-rules
 *
 * @param {object} frontend - holds the localizer- and walker-related methods
 *                         and state
 * @param {object} emit - the contextual emitters to the final buffer
 * @param {array} k - The parsed at-rule, including the parameters,
 *                    if takes both parameters and a block.
 *                    k == [match, fullAtRule, atRuleType, params?]
 *                    So in `@-webkit-keyframes foo`, we have
 *                     - match = "@-webkit-keyframes foo"
 *                     - fullAtRule = "@-webkit-keyframes"
 *                     - atRuleType = "keyframes"
 *                     - params = "foo"
 * @param {string|string[]|object|object[]} v - Either parameters for
 *                                              block-less rules or
 *                                              their block
 *                                              for the others.
 * @param {string} prefix - the current selector or the selector prefix
 *                          in case of nested rules
 * @param {boolean} local - are we in @local or in @global scope?
 * @param {string} nestingDepth - are we nested in an at-rule or a selector?
 */


export function modulesAtRules(next) {
  return function (frontend, emit, k, v, prefix, local, nestingDepth) {
    if (k[2] === 'global' && !k[3]) {

      rules(frontend, emit, prefix, v, 0, nestingDepth)


    } else if (k[2] === 'local' && !k[3]) {

      rules(frontend, emit, prefix, v, 1, nestingDepth)


    } else if (k[2] === 'adopt' && k[3]) {

      if (!local || nestingDepth) return emit.err('@adopt global or nested: ' + k[0])

      if (!/^\.?[_A-Za-z][-\w]*$/.test(k[3])) return emit.err('bad adopter ' + JSON.stringify(k[3]) + ' in ' + k[0])

      var classes = []
      flatIter(function(adoptee, asString) {

        if(adoptee == null || !/^\.?[_A-Za-z][-\w]*(?:\s+\.?[_A-Za-z][-\w]*)*$/.test(asString = adoptee + '')) emit.err('bad adoptee '+ JSON.stringify(adoptee) + ' in ' + k[0])

        else classes.push(asString.replace(/\./g, ''))

      })(v)

      // we may end up with duplicate classes but AFAIK it has no consequences on specificity.
      if (classes.length) {
        frontend.localize(k[3] = k[3].replace(/\./g, ''))
        frontend.names[k[3]] += (' ' + classes.join(' '))
      }

    } else {
      if (local && k[2] === 'keyframes' && k[3]) {

        k[3] = k[3].replace(
          // generated by script/regexps.js
          /(var\([^)]+\))|:?global\(\s*([_A-Za-z][-\w]*)\s*\)|()(-?[_A-Za-z][-\w]*)/,
          frontend.localizeReplacer
        )

      }
      next(frontend, emit, k, v, prefix, local, nestingDepth)
    }
  }
}
export function standardAtRules(next) {
  return function(frontend, emit, k, v, prefix, local, nestingDepth) {
    if ((k[2] === 'namespace' || k[2] === 'import' || k[2] === 'charset') && !k[3]) {
      flatIter(function(v) {

        emit.atrule(k[1], k[2], v)

      })(v)


    } else if (k[2] === 'font-face' || k[2] === 'page' || k[2] === 'viewport') {
      flatIter(function(v) {

        emit.atrule(k[1], k[2], k[3], 'decl')

        declarations(frontend, emit, '', v, local)

        emit._atrule()

      })(v)

    } else if (( k[2] === 'media'|| k[2] === 'supports') && k[3] || k[2] === 'keyframes') {

      if (k[2] === 'keyframes' && k[3] === '') {
        if(prefix !== '') {
          k[3] = randIdentifier(8)
          // this is necessary if the rule hasn't been opened yet
          // it is ignored if the rule is already opened.
          emit.rule(prefix)
          emit.decl('animation-name', k[3])
        } else {
          emit.err('Unexpected anonymous @keyframes out of selector')
          return
        }
      }


      emit.atrule(k[1], k[2], k[3], 'rule')

      rules(
        frontend, emit,
        'keyframes' == k[2] ? '' : prefix,
        v, local, nestingDepth + 1
      )

      emit._atrule()

    } else {

      next(frontend, emit, k, v, prefix, local, nestingDepth)

    }
  }
}

export function unsupportedAtRule(frontend, emit, k){
  emit.err('Unsupported at-rule: ' + k[0])
}
