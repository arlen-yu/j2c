import {flatIter} from './helpers'
import {rules} from './rules'
import {declarations} from './declarations'

/**
 * Handles a single at-rules
 *
 * @param {object} state - holds the localizer- and walker-related methods
 *                         and state
 * @param {object} emit - the contextual emitters to the final buffer
 * @param {array} k - The parsed at-rule, including the parameters,
 *                    if takes both parameters and a block.
 *                    k == [match, fullAtRule, atRuleType, params?]
 *                    So in `@-webkit-keyframes foo`, we have
 *                     - match = "@-webkit-keyframes foo"
 *                     - fullAtRule = "@-webkit-keyframes"
 *                     - atRuleType = "keyframes"
 *                     - params = "foo"
 * @param {string|string[]|object|object[]} v - Either parameters for
 *                                              block-less rules or
 *                                              their block
 *                                              for the others.
 * @param {string} prefix - the current selector or the selector prefix
 *                          in case of nested rules
 * @param {string} inAtRule - are we nested in an at-rule?
 * @param {boolean} local - are we in @local or in @global scope?
 */

export function atRules(state, emit, k, v, prefix, local, inAtRule) {

  // First iterate over user-provided at-rules and return if one of them corresponds to the current one
  for (var i = 0; i < state.$atHandlers.length; i++) {

    if (state.$atHandlers[i](state, emit, k, v, prefix, local, inAtRule)) return

  }

  // using `/^global$/.test(k[2])` rather that 'global' == k[2] gzips
  // slightly better thanks to the regexps tests further down.
  // It is slightly less efficient but this isn't a critical path.

  if (!k[3] && /^global$/.test(k[2])) {

    rules(state, emit, prefix, v, 0, inAtRule)


  } else if (!k[3] && /^local$/.test(k[2])) {

    rules(state, emit, prefix, v, 1, inAtRule)


  } else if (k[3] && /^adopt$/.test(k[2])) {

    if (!local || inAtRule) return emit.atrule('@-error-bad-at-adopt-placement' , '', JSON.stringify(k[0]), 0)

    if (!/^\.?[_A-Za-z][-\w]*$/.test(k[3])) return emit.atrule('@-error-bad-at-adopter', '', k[3], 0)

    i = []
    flatIter(function(adoptee, asString) {

      if(!/^\.?[_A-Za-z][-\w]*(?:\s+\.?[_A-Za-z][-\w]*)*$/.test(asString = adoptee.toString())) emit.atrule('@-error-bad-at-adoptee', '', JSON.stringify(adoptee), 0)

      else i.push(asString.replace(/\./g, ''))

    })(v)

    // we may end up with duplicate classes but AFAIK it has no consequences on specificity.
    if (i.length) {
      state.localize(k[3] = k[3].replace(/\./g, ''))
      state.names[k[3]] += (' ' + i.join(' '))
    }


  } else if (!k[3] && /^(?:namespace|import|charset)$/.test(k[2])) {
    flatIter(function(v) {

      emit.atrule(k[1], k[2], v)

    })(v)


  } else if (!k[3] && /^(?:font-face|viewport)$/.test(k[2])) {
    flatIter(function(v) {

      emit.atrule(k[1], k[2], k[3], 1)

      declarations(state, emit, '', v, local)

      emit._atrule()

    })(v)

  } else if (k[3] && /^(?:media|supports|page|keyframes)$/.test(k[2])) {

    if (local && 'keyframes' == k[2]) {
      k[3] = k[3].replace(
        // generated by script/regexps.js
        /(var\([^)]+\))|:?global\(\s*([_A-Za-z][-\w]*)\s*\)|()(-?[_A-Za-z][-\w]*)/,
        state.localizeReplacer
      )
    }


    emit.atrule(k[1], k[2], k[3], 1)

    if ('page' == k[2]) {

      declarations(state, emit, '', v, local)

    } else {

      rules(
        state, emit,
        'keyframes' == k[2] ? '' : prefix,
        v, local, 1
      )

    }

    emit._atrule()

  } else {

    emit.atrule('@-error-unsupported-at-rule', '', JSON.stringify(k[0]))

  }
}
