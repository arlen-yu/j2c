import {type, ARRAY, splitSelector, flatIter} from './helpers'
import {sheet} from './sheet'
import {declarations} from './declarations'

/**
 * Hanldes at-rules
 *
 * @param {string} k - The at-rule name, and, if takes both parameters and a
 *                     block, the parameters.
 * @param {string[]} emit - the contextual emitters to the final buffer
 * @param {string[]} v - Either parameters for block-less rules or their block
 *                       for the others.
 * @param {string} prefix - the current selector or a prefix in case of nested rules
 * @param {string} composes - the potential target of a @composes rule, if any
 * @param {boolean} local - are we in @local or in @global scope?
 * @param {object} state - helper functions to populate or create the @local namespace
 *                      and to @extend classes
 * @param {function} state.e - @extend helper
 * @param {function} state.l - @local helper
 */

export function at(k, v, emit, prefix, composes, local, state){
  var i, params
  if (/^.global$/.test(k)) {
    sheet(v, emit, prefix, 1, 0, state)

  } else if (/^.local$/.test(k)) {

    sheet(v, emit, prefix, 1, 1, state)

  } else if (/^.composes$/.test(k)) {
    if (!local) {

      return emit.a('@-error-at-composes-in-at-global', '', '', ';\n')

    }
    if (!composes) {

      return emit.a('@-error-at-composes-no-nesting', '', '', ';\n')

    }

    params = (type.call(v) == ARRAY ? v.join(' ') : v).replace(/\./g, '')

    // TODO: move this to the validation plugin.
    // if(!/^\s*\w[-\w]*(?:\s+\w[-\w]*)*\s*$/.test(params)) {
    //   return emit.a(
    //     '@-error-at-composes-invalid-character', ' ',
    //     JSON.stringify(params.match(/\b-|[^-\w\s]/)[0]) + ' in ' + JSON.stringify(v), ';\n')
    // }

    composes = splitSelector(composes)
    for(i = 0; i < composes.length; i++) {
      k = /^\s*\.(\w+)\s*$/.exec(composes[i])
      if (k == null) {
        // the last class is a :global(.one)

        emit.a('@-error-at-composes-bad-target', ' ', JSON.stringify(composes[i]), ';\n')

        continue
      }

      state.c(params, k[1]) //compose

    }

  } else if (/^.(?:-[\w]+-)?(?:namespace|import|charset)$/.test(k)) {
    flatIter(function(v) {

      emit.a(k, ' ', v, ';\n')

    })(v)

  } else if (/^.(?:-[\w]+-)?(?:font-face|viewport|swash|ornaments|annotation|stylistic|styleset|character-variant)$/.test(k)) {
    flatIter(function(v) {

      emit.a(k, '', '', ' {\n')

      declarations(v, emit, '', local, state)

      emit.c('}\n')

    })(v)

  } else if (/^.(?:-[\w]+-)?(?:media|supports|document|page|keyframes|counter-style|font-feature-values)\b\s*(\S.*)/.test(k)) {

    params = k.match(/^.(?:-[\w]+-)?(?:media|supports|document|page|keyframes|counter-style|font-feature-values)\b\s*(\S.*)/)[1]

    k = k.match(/^.(?:-[\w]+-)?(?:media|supports|document|page|keyframes|counter-style|font-feature-values)/)[0]

    if (local && /^.(?:-[\w]+-)?(?:keyframes|counter-style)/.test(k)) {
      params = params.replace(
        // generated by script/regexps.js
        /:?global\(\s*([-\w]+)\s*\)|()([-\w]+)/,
        state.l
      )
    }


    emit.a(k, ' ', params, ' {\n')

    if (/.(?:-[\w]+-)?(?:page|counter-style)/.test(k)) {

      declarations(v, emit, '', local, state)

    } else {

      sheet(v, emit, prefix, 1, local, state)

    }

    emit.c('}\n')

  } else {

    emit.a('@-error-unsupported-at-rule', ' ', JSON.stringify(k), ';\n')

  }
}
