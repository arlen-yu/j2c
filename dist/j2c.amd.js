define(function () { 'use strict';

  var emptyArray = [];
  var emptyObject = {};
  var type = emptyObject.toString;
  var ARRAY =  type.call(emptyArray);
  var OBJECT = type.call(emptyObject);
  var STRING = type.call('');
  var FUNCTION = type.call(type);
  var own =  emptyObject.hasOwnProperty;
  function cartesian(a,b) {
    var res = [], i, j
    for (j in b) if(own.call(b, j))
      for (i in a) if(own.call(a, i))
        res.push(a[i] + b[j])
    return res
  }

  // "Tokenizes" the selectors into parts relevant for the next function.
  // Strings and comments are matched, but ignored afterwards.
  // This is not a full tokenizers. It only recognizes comas, parentheses,
  // strings and comments.
  // regexp generated by scripts/regexps.js then trimmed by hand
  var selectorTokenizer = /[(),]|"(?:\\.|[^"\n])*"|'(?:\\.|[^'\n])*'|\/\*[\s\S]*?\*\//g


  /**
   * This will split a coma-separated selector list into individual selectors,
   * ignoring comas in strings, comments and in :pseudo-selectors(parameter, lists).
   * @param {string} selector
   * @return {string[]}
   */

  function splitSelector(selector) {
    var indices = [], res = [], inParen = 0, o
    /*eslint-disable no-cond-assign*/
    while(o = selectorTokenizer.exec(selector)) {
    /*eslint-enable no-cond-assign*/
      switch(o[0]){
      case '(': inParen++; break
      case ')': inParen--; break
      case ',': if (inParen) break; indices.push(o.index)
      }
    }
    for (o = indices.length; o--;){
      res.unshift(selector.slice(indices[o] + 1))
      selector = selector.slice(0, indices[o])
    }
    res.unshift(selector)
    return res
  }

  // This is like the `selectorTokenizer`, but for the `&` operator

  var ampersandTokenizer = /&|"(?:\\.|[^"\n])*"|'(?:\\.|[^'\n])*'|\/\*[\s\S]*?\*\//g

  function ampersand (selector, parents) {
    var indices = [], split = [], res, o
    /*eslint-disable no-cond-assign*/
    while(o = ampersandTokenizer.exec(selector)) {
    /*eslint-enable no-cond-assign*/
      if (o[0] == '&') indices.push(o.index)
    }
    for (o = indices.length; o--;){
      split.unshift(selector.slice(indices[o] + 1))
      selector = selector.slice(0, indices[o])
    }
    split.unshift(selector)
    res = [split[0]]
    for (o = 1; o < split.length; o++) {
      res = cartesian(res, cartesian(parents, [split[o]]))
    }
    return res.join(',')
  }

  function flatIter (f) {
    return function iter(arg) {
      if (type.call(arg) === ARRAY) for (var i= 0 ; i < arg.length; i ++) iter(arg[i])
      else f(arg)
    }
  }

  function decamelize(match) {
    return '-' + match.toLowerCase()
  }

  /**
   * Handles the property:value; pairs.
   *
   * @param {array|object|string} o - the declarations.
   * @param {string[]} emit - the contextual emitters to the final buffer
   * @param {string} prefix - the current property or a prefix in case of nested
   *                          sub-properties.
   * @param {boolean} local - are we in @local or in @global scope.
   * @param {object} state - helper functions to populate or create the @local namespace
   *                      and to @extend classes.
   * @param {function} state.e - @extend helper.
   * @param {function} state.l - @local helper.
   */

  function declarations(o, emit, prefix, local, state) {
    var k, v, kk
    if (o==null) return
    if (/\$/.test(prefix)) {
      for (kk in (prefix = prefix.split('$'))) if (own.call(prefix, kk)) {

        declarations(o, emit, prefix[kk], local, state)

      }
      return
    }
    switch ( type.call(o = o.valueOf()) ) {
    case ARRAY:
      for (k = 0; k < o.length; k++)

        declarations(o[k], emit, prefix, local, state)

      break
    case OBJECT:
      // prefix is falsy iif it is the empty string, which means we're at the root
      // of the declarations list.
      prefix = (prefix && prefix + '-')
      for (k in o) if (own.call(o, k)){
        v = o[k]
        if (/\$/.test(k)) {
          for (kk in (k = k.split('$'))) if (own.call(k, kk)) {

            declarations(v, emit, prefix + k[kk], local, state)

          }
        } else {

          declarations(v, emit, prefix + k, local, state)

        }
      }
      break
    default:
      // prefix is falsy when it is "", which means that we're
      // at the top level.
      // `o` is then treated as a `property:value` pair, or a
      // semi-colon-separated list thereof.
      // Otherwise, `prefix` is the property name, and
      // `o` is the value.

      // restore the dashes
      k = prefix.replace(/_/g, '-').replace(/[A-Z]/g, decamelize)

      if (local && (k == 'animation-name' || k == 'animation' || k == 'list-style')) {
        // no need to tokenize here a plain `.split(',')` has all bases covered.
        // We may 'localize' a comment, but it's not a big deal.
        o = o.split(',').map(function (o) {
          return o.replace(/:?global\(\s*([-\w]+)\s*\)|()([-\w]+)/, state.l)
        }).join(',')
      }

      emit.d(k, k ? ':': '', o, ';\n')

    }
  }

  /**
   * Hanldes at-rules
   *
   * @param {string} k - The at-rule name, and, if takes both parameters and a
   *                     block, the parameters.
   * @param {string[]} emit - the contextual emitters to the final buffer
   * @param {string[]} v - Either parameters for block-less rules or their block
   *                       for the others.
   * @param {string} prefix - the current selector or a prefix in case of nested rules
   * @param {string} composes - the potential target of a @composes rule, if any
   * @param {boolean} local - are we in @local or in @global scope?
   * @param {object} state - helper functions to populate or create the @local namespace
   *                      and to @extend classes
   * @param {function} state.e - @extend helper
   * @param {function} state.l - @local helper
   */

  function at$1(k, v, emit, prefix, composes, local, state){
    var i, params
    if (/^.global$/.test(k)) {
      sheet(v, emit, prefix, 1, 0, state)

    } else if (/^.local$/.test(k)) {

      sheet(v, emit, prefix, 1, 1, state)

    } else if (/^.composes$/.test(k)) {
      if (!local) {

        return emit.a('@-error-at-composes-in-at-global', '', '', ';\n')

      }
      if (!composes) {

        return emit.a('@-error-at-composes-no-nesting', '', '', ';\n')

      }

      params = (type.call(v) == ARRAY ? v.join(' ') : v).replace(/\./g, '')

      // TODO: move this to the validation plugin.
      // if(!/^\s*\w[-\w]*(?:\s+\w[-\w]*)*\s*$/.test(params)) {
      //   return emit.a(
      //     '@-error-at-composes-invalid-character', ' ',
      //     JSON.stringify(params.match(/\b-|[^-\w\s]/)[0]) + ' in ' + JSON.stringify(v), ';\n')
      // }

      composes = splitSelector(composes)
      for(i = 0; i < composes.length; i++) {
        k = /^\s*\.(\w+)\s*$/.exec(composes[i])
        if (k == null) {
          // the last class is a :global(.one)

          emit.a('@-error-at-composes-bad-target', ' ', JSON.stringify(composes[i]), ';\n')

          continue
        }

        state.c(params, k[1]) //compose

      }

    } else if (/^.(?:-[\w]+-)?(?:namespace|import|charset)$/.test(k)) {
      flatIter(function(v) {

        emit.a(k, ' ', v, ';\n')

      })(v)

    } else if (/^.(?:-[\w]+-)?(?:font-face|viewport|swash|ornaments|annotation|stylistic|styleset|character-variant)$/.test(k)) {
      flatIter(function(v) {

        emit.a(k, '', '', ' {\n')

        declarations(v, emit, '', local, state)

        emit.c('}\n')

      })(v)

    } else if (/^.(?:-[\w]+-)?(?:media|supports|document|page|keyframes|counter-style|font-feature-values)\b\s*(\S.*)/.test(k)) {

      params = k.match(/^.(?:-[\w]+-)?(?:media|supports|document|page|keyframes|counter-style|font-feature-values)\b\s*(\S.*)/)[1]

      k = k.match(/^.(?:-[\w]+-)?(?:media|supports|document|page|keyframes|counter-style|font-feature-values)/)[0]

      if (local && /^.(?:-[\w]+-)?(?:keyframes|counter-style)/.test(k)) {
        params = params.replace(
          // generated by script/regexps.js
          /:?global\(\s*([-\w]+)\s*\)|()([-\w]+)/,
          state.l
        )
      }


      emit.a(k, ' ', params, ' {\n')

      if (/.(?:-[\w]+-)?(?:page|counter-style)/.test(k)) {

        declarations(v, emit, '', local, state)

      } else {

        sheet(v, emit, prefix, 1, local, state)

      }

      emit.c('}\n')

    } else {

      emit.a('@-error-unsupported-at-rule', ' ', JSON.stringify(k), ';\n')

    }
  }

  /**
   * Add rulesets and other CSS statements to the sheet.
   *
   * @param {array|string|object} statements - a source object or sub-object.
   * @param {string[]} emit - the contextual emitters to the final buffer
   * @param {string} prefix - the current selector or a prefix in case of nested rules
   * @param {string} composes - the potential target of a @composes rule, if any
   * @param {boolean} local - are we in @local or in @global scope?
   * @param {object} state - helper functions to populate or create the @local namespace
   *                      and to @composes classes
   * @param {function} state.e - @composes helper
   * @param {function} state.l - @local helper
   */
  function sheet(statements, emit, prefix, composes, local, state) {
    var k, v, inDeclaration, kk

    switch (type.call(statements)) {

    case ARRAY:
      for (k = 0; k < statements.length; k++){

        sheet(statements[k], emit, prefix, composes, local, state)

      }
      break

    case OBJECT:
      for (k in statements) if (own.call(statements, k)) {
        v = statements[k]
        if (prefix && /^[-\w$]+$/.test(k)) {
          if (!inDeclaration) {
            inDeclaration = 1

            emit.s((prefix), ' {\n')

          }

          declarations(v, emit, k, local, state)

        } else if (/^@/.test(k)) {
          // Handle At-rules

          inDeclaration = (inDeclaration && emit.c('}\n') && 0)

          at$1(k, v, emit, prefix, composes, local, state)

        } else {
          // selector or nested sub-selectors

          inDeclaration = (inDeclaration && emit.c('}\n') && 0)

          sheet(v, emit,
            (/,/.test(prefix) || prefix && /,/.test(k)) ?
            /*0*/ (kk = splitSelector(prefix), splitSelector( local ?

                k.replace(
                  /:global\(\s*(\.[-\w]+)\s*\)|(\.)([-\w]+)/g, state.l
                ) : k

              ).map(function (k) {
                return /&/.test(k) ? ampersand(k, kk) : kk.map(function(kk) {
                  return kk + k
                }).join(',')
              }).join(',')) :
            /*0*/ /&/.test(k) ?
              /*1*/ ampersand(
                local ?

                  k.replace(
                    /:global\(\s*(\.[-\w]+)\s*\)|(\.)([-\w]+)/g, state.l
                  ) :

                  k,
                [prefix]
              ) :
              /*1*/ prefix + (
                local ?

                  k.replace(
                    /:global\(\s*(\.[-\w]+)\s*\)|(\.)([-\w]+)/g, state.l
                  ) :

                  k
                ),
            composes || prefix ? '' : k,
            local, state
          )
        }
      }

      if (inDeclaration) emit.c('}\n')

      break
    case STRING:
      // CSS hacks or ouptut of `j2c.inline`.

      emit.s(( prefix || ':-error-no-selector' ) , ' {\n')

      declarations(statements, emit, '', local, state)

      emit.c('}\n')
    }
  }

  function global(x) {
    return ':global(' + x + ')'
  }


  function kv (k, v, o) {
    o = {}
    o[k] = v
    return o
  }

  function at (rule, params, block) {
    if (
      arguments.length < 3
    ) {
      var _at = at.bind.apply(at, [null].concat([].slice.call(arguments,0)))
      _at.toString = function(){return '@' + rule + ' ' + params}
      return _at
    }
    else return kv('@' + rule +' ' + params, block)
  }

  function j2c() {
    var filters = []
    var instance = {
      at: at,
      global: global,
      kv: kv,
      names: {},
      suffix: '__j2c-' +
        Math.floor(Math.random() * 0x100000000).toString(36) + '-' +
        Math.floor(Math.random() * 0x100000000).toString(36) + '-' +
        Math.floor(Math.random() * 0x100000000).toString(36) + '-' +
        Math.floor(Math.random() * 0x100000000).toString(36),
      use: function() {
        _use(emptyArray.slice.call(arguments))
        return instance
      },
      $plugins: []
    }

    function _default(target, source) {
      for (var k in source) if (own.call(source, k) && k.indexOf('$')) {
        if (OBJECT == type.call(source[k]) && OBJECT == type.call(target[k])) _default(target[k], source[k])
        else if (!(k in target)) target[k] = source[k]
      }
    }

    var _use = flatIter(function(plugin) {
      // `~n` is falsy for `n === -1` and truthy otherwise.
      // Works well to turn the  result of `a.indexOf(x)`
      // into a value that reflects the presence of `x` in
      // `a`.
      if (~instance.$plugins.indexOf(plugin)) return

      instance.$plugins.push(plugin)

      if (type.call(plugin) === FUNCTION) plugin = plugin(instance)

      if (!plugin) return

      flatIter(function(filter) {
        filters.push(filter)
      })(plugin.$filter||[])

      _default(instance, plugin)
    })

    function makeEmitter(inline) {
      var buf = []
      function push() {
        emptyArray.push.apply(buf, arguments)
      }
      var emit = {
        x: function(raw){return raw ? buf : buf.join('')},   // buf
        a: push, // at-rules
        s: push, // selector
        d: push, // declaration
        c: push  // close
      }
      for (var i = filters.length; i--;) emit = filters[i](emit, inline)
      return emit
    }

    var state = {
      c: function composes(parent, child) {
        instance.names[child] = instance.names[child] + ' ' + parent
      },
      l: function localize(match, global, dot, name) {
        if (global) return global
        if (!instance.names[name]) instance.names[name] = name + instance.suffix
        return dot + instance.names[name].match(/^\S+/)
      }
    }

  /*/-statements-/*/
    instance.sheet = function(statements, emit) {
      sheet(
        statements,
        emit = makeEmitter(false),
        '', '',     // prefix and compose
        1,          // local, by default
        state
      )

      return emit.x()
    }
  /*/-statements-/*/
    instance.inline = function (_declarations, emit) {
      declarations(
        _declarations,
        emit = makeEmitter(true),
        '',         // prefix
        1,          //local
        state
      )
      return emit.x()
    }

    return instance
  }

  var _j2c = j2c()
  'sheet|inline|names|at|global|kv|suffix'.split('|').map(function(m){j2c[m] = _j2c[m]})

  return j2c;

});